#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
#define int long long
const int inf = 1e15 + 7;
int n;
struct edge {
    int a, b, flow = 0, c;
    edge() {
        a = 0, b = 0, flow = 0;
    }
    edge(int _a, int _b, int _c) {
        a = _a, b = _b, c = _c;
    }
};
vector<edge> E;
vector<vector<int>> g;
void insert_edge(int a, int b, int c) {
    E.push_back(edge(a, b, c));
    g[a].push_back(E.size() - 1);
    E.push_back(edge(b, a, 0));
    g[b].push_back(E.size() - 1);
}
vector<int> d;
bool bfs(int s, int t, int b) {
    queue<int> q;
    d = vector<int>(n, inf);
    d[s] = 0;
    q.push(s);
    vector<int> used(n);
    used[0] = 1;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (auto p : g[v]) {
            edge& e = E[p];
            if (e.c - e.flow < b) continue;
            if (!used[e.b]) {
                used[e.b] = 1;
                q.push(e.b);
                d[e.b] = d[e.a] + 1;
            }
        }
    }
    return (used[t]);
}
vector<int> ind, path;
bool dfs(int s, int t, int b) {
    if (d[s] >= d[t]) return (s == t);
    for (; ind[s] < g[s].size(); ++ind[s]) {
        edge& e = E[g[s][ind[s]]];
        if (d[e.b] == d[e.a] + 1 && e.c - e.flow >= b && dfs(e.b, t, b)) {
            path.push_back(g[s][ind[s]]);
            return true;
        }
    }
    return false;
}
void block() {
    int minf = inf;
    for (auto elem : path) {
        minf = min(minf, E[elem].c - E[elem].flow);
    }
    for (auto elem : path) {
        E[elem].flow += minf;
        E[elem ^ 1].flow -= minf;
    }
    path.clear();
}
int maxflow(int s, int t) {
    for (int b = (1 << 30); b; b >>= 1) {
        path.clear();
        while (bfs(s, t, b)) {
            ind = vector<int>(n);
            while (dfs(s, t, b)) {
                block();
            }
        }
    }
    int ans = 0;
    for (auto elem : g[s]) {
        ans += E[elem].flow;
    }
    return ans;
}
int32_t main() {
    cin >> n;
    g.resize(n);
    ind.resize(n);
    d.resize(n);
    int m;
    cin >> m;
    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;
        --a, --b;
        insert_edge(a, b, c);
    }
    cout << maxflow(0, n - 1);
}
